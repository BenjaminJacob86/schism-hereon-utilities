import sys
import os
""" Code to expand schism downscaling for child model boundaries that liew within dry follaing areay of mother model
so that the schism interpolate_vraibale utilities where used with limitted boudanry.
In mother dry areay child model takes over vertical mean T and S values of nn profiles in mothder model both if wet and and dry
the simulated elevation if wet and sea level 0 if dry. For uv the vertical mean of nn profile if wet and zero if dry
 """

sys.path.insert(0,'/home/g/g260114/schism-hzg-utilities/')
from schism import* # import schism class to read grid structure
import glob
# gen forcing using nudign scripts for reduced boundary
# overwrite neareas neighbour for missing boundaries


# schout style:
ncdir='/work/gg0028/g260114/RUNS/BLACKSEA/RUN24d/RUN24d/new_code/constant_bd/outputs_all/'
schismfiles=[] 
for iorder in range(8): # check for schout_nc files until 99999
	schismfiles+=glob.glob(ncdir+'schout_'+'?'*iorder+'.nc')
nrs=[int(file[file.rfind('_')+1:file.index('.nc')]) for file in schismfiles]
schismfiles=list(np.asarray(schismfiles)[np.argsort(nrs)])
nrs=list(np.asarray(nrs)[np.argsort(nrs)])


s0dir='/work/gg0028/g260114/RUNS/BLACKSEA/RUN24d/RUN24d/new_code/constant_bd/' # mother grid
#s1dir='/work/gg0028/g260114/RUNS/GermanBight/GB_2017_wave_sed/ClimateProj/'                    # desitiantion grid reduced bd
#s2dir='/work/gg0028/g260114/RUNS/GermanBight/GB_2017_wave_sed/ClimateProj/'					   # destination grid full bd
s1orgdir='/work/gg0028/g260114/RUNS/BLACKSEA/NWBS2b_BSRUN24d_downscaling/'

#os.chdir(s1orgdir)
#s1org=schism_setup(vgrid_file='vgrid.in.old')
os.chdir(s0dir)
#s0=schism_setup(hgrid_file='bg.gr3')
s0=schism_setup(vgrid_file='vgrid.in.old')
#os.chdir(s1dir)
#s1=schism_setup(hgrid_file='fg.gr3')
s1=schism_setup(vgrid_file='vgrid.in.old')

#nvertmax=21 #max number of vertical layers in destination grid

#acc=schism_output2('/work/gg0028/g260114/RUNS/GermanBight/GB_2017_wave_sed/ClimateProj/forcingFromSNS/sub').nc # to much space
os.chdir('/work/gg0028/g260114/RUNS/GermanBight/GB_2017_wave_sed/ClimateProj/forcingFromSNS/')


appendbds=np.asarray([ibd-1 for ibd in s1org.bdy_segments[0] if ibd not in s1.bdy_segments[0]])
appendbds_indx=[ibd-1 for ibd in s1org.bdy_segments[0] if ibd not in s1.bdy_segments[0]]
s0.init_node_tree(latlon=False)
xbd=np.asarray(s1.x)[appendbds]
ybd=np.asarray(s1.y)[appendbds]
bdcoords=list(zip(xbd,ybd))
nnpoints=s0.node_tree_xy.query(bdcoords)[1]

insert_index=[np.where(s1org.bdy_segments[0]==ibd+1)[0][0] for ibd in appendbds]
#insert_index=insert_index[1:]

#for ibd in appendbds:
#	print(ibd)
#	s1org.bdy_segments[0].index([ibd+1]) 


# find nearest element centers for dry assessment
# element centers
x0,y0=np.asarray(s0.x),np.asarray(s0.y)
cx=np.mean(x0[s0.nvplt],axis=1)
cy=np.mean(y0[s0.nvplt],axis=1)
elcoords=[[cx[i],cy[i]] for i in range(len(cx))] # pooint pairs of nodes
elem_nn_tree = cKDTree(elcoords) # next neighbour search tree	     



# load th.nc generated by interpolat_variables
dsin=xr.open_dataset('elev2D.th.nc')
elevin=dsin['time_series'].values
dsin=xr.open_dataset('SAL_3D.th.nc')
saltin=dsin['time_series'].values
dsin=xr.open_dataset('TEM_3D.th.nc')
tempin=dsin['time_series'].values
dsin=xr.open_dataset('uv3D.th.nc')
uvin=dsin['time_series'].values

nt,nnodes_wet,nz,_=tempin.shape

# fill intersecting
#isect,ainb,bina=np.intersect1d(np.asarray(s1.bdy_segments[0]),np.asarray(s1org.bdy_segments[0]),return_indices=True)
isect,ainb,bina=np.intersect1d(np.asarray(s1.bdy_segments[0][1:]),np.asarray(s1org.bdy_segments[0]),return_indices=True) #temporary test
np.asarray(s1.bdy_segments[0])[ainb]==np.asarray(s1org.bdy_segments[0])[bina]
elev=np.zeros((nt,len(s1org.bdy_segments[0]),1,1))
T=np.zeros((nt,len(s1org.bdy_segments[0]),nz,1))
S=np.zeros((nt,len(s1org.bdy_segments[0]),nz,1))
uv=np.zeros((nt,len(s1org.bdy_segments[0]),nz,2))

# overtake alreay present data
elev[:,ainb,:]=elevin[:,ainb,:]
S[:,ainb,:]=tempin[:,ainb,:]
T[:,ainb,:]=saltin[:,ainb,:]
uv[:,ainb,:]=uvin[:,ainb,:]

D=np.asarray(s1.depths) # depths in destination grid


igridnode=np.asarray(s1org.bdy_segments[0])[insert_index]-1 # grid nodes to be filled
nn_element=elem_nn_tree.query(list(zip(xbd,ybd)))[1] #nearest element to subset of boundarypoints that can potetnielly fall dry
check_elem=s0.nvplt2nvp[nn_element] # original element indices with respect to non splitted grid

D[igridnode]	
Dstack=np.tile(D[igridnode],(nt_stack,1))
drydepth=   #set water level to this value if parent model is dry at open bd

file=schismfiles[0]
ds=xr.open_dataset(file)
nt_stack=len(ds.time)

insert_index=np.asarray(insert_index)

#plt.clim((-4,4))

#ph,ch,ax=s1.plotAtnodes(s1.depths)
#ph.set_clim((-2,2))
 
insert_logic=np.zeros(elev.shape[1],bool)
insert_logic[insert_index]=True

#what kind of date usefull, mon 6 deliverable
#answer to questions in a month
s1org.plot_domain_boundaries(latlon=False)
plt.plot(cx[nn_element],cy[nn_element],'k+')

insert_index_stack=np.tile(insert_index,(nt_stack,1))

for i,file in enumerate(schismfiles):
	tinds=i*nt_stack+np.arange(nt_stack)

	print(file)
	ds=xr.open_dataset(file)
	dsnn=ds.sel(nSCHISM_hgrid_node=nnpoints)	
	delnn=ds.sel(nSCHISM_hgrid_face=check_elem)	
	isdry=np.asarray(delnn.wetdry_elem.values,bool)
	iswet=~isdry

	# user values from nearest model points
	elevvals=dsnn['elev'].values
	Tvals=dsnn['temp'].values
	Svals=dsnn['salt'].values
	uvvals=dsnn['hvel'].values
	# for T and S use the remaining stored values (need to correct if dummy)
	tmean=Tvals.mean(axis=2)
	smean=Svals.mean(axis=2)
	uvmean=uvvals.mean(axis=2)
	
	for iz in range(nvertmax):
		T[tinds,:][:,insert_index,iz,0]=tmean # mean value from two layers
		S[tinds,:][:,insert_index,iz,0]=smean # mean value from two layers
		uv[tinds,:][:,insert_index,iz,0][iswet]=uvmean[:,:,0][iswet] #take wet value	
		uv[tinds,:][:,insert_index,iz,1][iswet]=uvmean[:,:,1][iswet]
	elev[tinds,:][:,insert_index,0,0][iswet]=elevvals[iswet] # leave sea level at zero

time= dsin['time'].values	
s1org.write_bdy_netcdf('elev_2D_expand.th.nc',time,elev)
s1org.write_bdy_netcdf('SAL_3D_expand.th.nc',time,S)
s1org.write_bdy_netcdf('TEM_3D_expand.th.nc',time,T)
s1org.write_bdy_netcdf('uv3D_expand.th.nc',time,uv)

